<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmarterGerman Analytics Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #f8f9fa;
        color: #333;
    }
    
    .dashboard {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
    }
    
    .header {
        background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
        color: white;
        padding: 30px;
        border-radius: 12px;
        margin-bottom: 30px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .header h1 {
        font-size: 28px;
        font-weight: 700;
    }
    
    .api-setup {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 30px;
        border: 2px solid #e9ecef;
    }
    
    .api-form {
        display: flex;
        gap: 15px;
        align-items: end;
        flex-wrap: wrap;
    }
    
    .form-group {
        flex: 1;
        min-width: 200px;
    }
    
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #374151;
    }
    
    .form-group input {
        width: 100%;
        padding: 10px;
        border: 2px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .connect-btn {
        background: #ff6b35;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
        white-space: nowrap;
    }
    
    .connect-btn:hover {
        background: #e55a2b;
    }
    
    .connect-btn:disabled {
        background: #9ca3af;
        cursor: not-allowed;
    }
    
    .error {
        background: #fef2f2;
        border: 1px solid #fecaca;
        color: #b91c1c;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    .success-info {
        margin-top: 15px;
        padding: 15px;
        background: #f0f9ff;
        border: 1px solid #0ea5e9;
        border-radius: 8px;
        font-size: 14px;
        color: #0369a1;
    }
    
    .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .metric-card {
        background: white;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        border-left: 4px solid #ff6b35;
    }
    
    .metric-value {
        font-size: 32px;
        font-weight: 700;
        color: #ff6b35;
        margin-bottom: 5px;
    }
    
    .metric-label {
        color: #6b7280;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 12px;
        letter-spacing: 0.5px;
    }
    
    .main-content {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        text-align: center;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        color: #6b7280;
    }
    
    .debug-info {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
        color: #666;
    }
    
    @media (max-width: 768px) {
        .api-form {
            flex-direction: column;
            align-items: stretch;
        }
        
        .header {
            flex-direction: column;
            text-align: center;
            gap: 15px;
        }
        
        .form-group {
            min-width: auto;
        }
    }
</style>
```

</head>
<body>
    <div class="dashboard">
        <div class="header">
            <div>
                <h1>SmarterGerman Analytics Dashboard</h1>
                <p>Connect via WordPress proxy to access real-time Teachable data</p>
            </div>
            <div id="connectionStatus" class="connection-status">
                <span style="color: #fca5a5;">Not Connected</span>
            </div>
        </div>

```
    <div class="api-setup">
        <div class="api-form">
            <div class="form-group">
                <label for="apiKey">Teachable API Key</label>
                <input type="password" id="apiKey" placeholder="Enter your Teachable API key">
            </div>
            <div class="form-group">
                <label for="schoolDomain">School Domain</label>
                <input type="text" id="schoolDomain" placeholder="smarterbusiness.teachable.com" value="smarterbusiness.teachable.com">
            </div>
            <div class="form-group">
                <label for="proxyURL">WordPress Proxy URL</label>
                <input type="text" id="proxyURL" placeholder="https://smartergerman.com/teachable-proxy.php" value="https://smartergerman.com/teachable-proxy.php">
            </div>
            <div class="form-group">
                <label>&nbsp;</label>
                <button class="connect-btn" onclick="connectAPI()">Connect via WordPress</button>
            </div>
        </div>
        <div class="success-info">
            <strong>🔒 Secure:</strong> API key sent to your WordPress proxy, never stored on GitHub Pages<br>
            <strong>✅ Fixed:</strong> Corrected API base URL to developers.teachable.com<br>
            <strong>⚡ Enhanced:</strong> Aggressive loading for 50k+ students with spot-check recovery
        </div>
    </div>
    
    <div id="errorMessage" class="error" style="display: none;"></div>
    
    <div id="metricsGrid" class="metrics-grid" style="display: none;">
        <div class="metric-card">
            <div class="metric-value" id="totalStudents">0</div>
            <div class="metric-label">Total Students</div>
        </div>
        <div class="metric-card">
            <div class="metric-value" id="totalCourses">0</div>
            <div class="metric-label">Active Courses</div>
        </div>
        <div class="metric-card">
            <div class="metric-value" id="avgProgress">0%</div>
            <div class="metric-label">Average Progress</div>
        </div>
        <div class="metric-card">
            <div class="metric-value" id="completedCourses">0</div>
            <div class="metric-label">Completed Courses</div>
        </div>
    </div>
    
    <div id="mainContent" class="main-content" style="display: none;">
        <div class="loading">Advanced dashboard will load here after successful connection...</div>
    </div>
</div>

<script>
    let teachableAPI = null;
    
    class TeachableAPI {
        constructor(apiKey, schoolDomain, proxyURL) {
            this.apiKey = apiKey;
            this.baseURL = 'https://developers.teachable.com/v1';
            this.schoolDomain = schoolDomain;
            this.proxyURL = proxyURL;
        }
        
        async request(endpoint, method = 'GET', data = null) {
            const requestData = {
                apiKey: this.apiKey,
                endpoint: endpoint,
                method: method
            };
            
            if (data) {
                requestData.data = data;
            }
            
            console.log('Sending request to proxy:', this.proxyURL);
            console.log('Request data:', { ...requestData, apiKey: '[HIDDEN]' });
            
            try {
                const response = await fetch(this.proxyURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('Proxy Response Status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.log('Error response:', errorText);
                    
                    if (response.status === 401) {
                        throw new Error('Invalid API key or unauthorized access');
                    } else if (response.status === 403) {
                        throw new Error('API access forbidden - check your Teachable plan (Pro+ required)');
                    } else if (response.status === 404) {
                        throw new Error('API endpoint not found - check your API configuration');
                    } else {
                        throw new Error(`Proxy Error: ${response.status} - ${errorText.substring(0, 200)}`);
                    }
                }
                
                const responseData = await response.json();
                console.log('API Response Data:', responseData);
                return responseData;
                
            } catch (error) {
                console.error('API Request failed:', error);
                throw error;
            }
        }
        
        async getCourses() {
            return this.request('/courses');
        }
        
        async getUsers(page = 1) {
            return this.request(`/users?page=${page}&per_page=100`);
        }
        
        async getEnrollments(page = 1) {
            return this.request(`/enrollments?page=${page}&per_page=100`);
        }
        
        async getUserProgress(userId) {
            return this.request(`/users/${userId}/enrollments`);
        }
        
        async getCourseProgress(courseId) {
            return this.request(`/courses/${courseId}/progress`);
        }
        
        async getCourseEnrollments(courseId, page = 1) {
            return this.request(`/courses/${courseId}/enrollments?page=${page}&per_page=100`);
        }
        
        async getUsersByTag(tag) {
            return this.request(`/users?tag=${encodeURIComponent(tag)}`);
        }
        
        async getUserDetails(userId) {
            return this.request(`/users/${userId}`);
        }
        
        async getCourseLectures(courseId) {
            return this.request(`/courses/${courseId}/lectures`);
        }
        
        async getLectureQuizzes(courseId, lectureId) {
            return this.request(`/courses/${courseId}/lectures/${lectureId}/quizzes`);
        }
        
        async getCourseDetails(courseId) {
            return this.request(`/courses/${courseId}`);
        }
        
        async testConnection() {
            try {
                console.log('Testing connection...');
                const courses = await this.getCourses();
                console.log('Test connection result:', courses);
                return courses && (courses.courses || courses);
            } catch (error) {
                console.error('Connection test failed:', error);
                return false;
            }
        }
    }
    
    async function connectAPI() {
        const apiKey = document.getElementById('apiKey').value.trim();
        const schoolDomain = document.getElementById('schoolDomain').value.trim();
        const proxyURL = document.getElementById('proxyURL').value.trim();
        
        if (!apiKey || !schoolDomain || !proxyURL) {
            showError('Please enter API key, school domain, and proxy URL');
            return;
        }
        
        const connectBtn = document.querySelector('.connect-btn');
        connectBtn.disabled = true;
        connectBtn.textContent = 'Connecting...';
        
        try {
            teachableAPI = new TeachableAPI(apiKey, schoolDomain, proxyURL);
            const coursesData = await teachableAPI.testConnection();
            
            if (coursesData) {
                document.getElementById('connectionStatus').innerHTML = '<span style="color: #10b981;">✓ Connected via WordPress</span>';
                document.getElementById('metricsGrid').style.display = 'grid';
                document.getElementById('mainContent').style.display = 'block';
                hideError();
                
                await loadDashboardData();
                
                // Clear API key for security
                document.getElementById('apiKey').value = '';
                
            } else {
                throw new Error('Failed to authenticate with Teachable API via proxy');
            }
        } catch (error) {
            showError(`Connection failed: ${error.message}`);
            document.getElementById('connectionStatus').innerHTML = '<span style="color: #ef4444;">Connection Failed</span>';
        }
        
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect via WordPress';
    }
    
    async function loadDashboardData() {
        try {
            console.log('Loading comprehensive analytics dashboard with advanced features...');
            
            // 1. Parallel laden: Kurse + Free-A1 Users
            const coursesPromise = teachableAPI.getCourses();
            const freeA1UsersPromise = teachableAPI.getUsersByTag('Free-A1').catch(e => {
                console.warn('Free-A1 tag search failed:', e);
                return { users: [] };
            });
            
            // 2. Aggressivere User-Loading für große Datenmengen
            console.log('Starting aggressive user loading for large datasets...');
            let batchSize = 3; // Noch konservativer für 50k+ Users
            let allUsers = [];
            let currentBatch = 1;
            let rateLimitDetected = false;
            let consecutiveEmptyBatches = 0;
            const maxConsecutiveEmpty = 5; // Mehr Toleranz für leere Batches
            
            while (consecutiveEmptyBatches < maxConsecutiveEmpty && allUsers.length < 80000) {
                const batchPromises = [];
                const startPage = (currentBatch - 1) * batchSize + 1;
                const endPage = startPage + batchSize - 1;
                
                for (let page = startPage; page <= endPage; page++) {
                    batchPromises.push(
                        teachableAPI.getUsers(page).catch(error => {
                            console.warn(`Page ${page} failed:`, error);
                            if (error.message.includes('429') || error.message.includes('rate') || error.message.includes('limit')) {
                                rateLimitDetected = true;
                            }
                            return { users: [] };
                        })
                    );
                }
                
                console.log(`Loading batch ${currentBatch} (pages ${startPage}-${endPage}, batch size: ${batchSize})...`);
                
                const startTime = Date.now();
                const batchResults = await Promise.all(batchPromises);
                const endTime = Date.now();
                
                // Rate Limit Management
                if (rateLimitDetected) {
                    console.log('Rate limit detected, reducing batch size and adding longer delay...');
                    batchSize = 1; // Auf einzelne Requests reduzieren
                    await new Promise(resolve => setTimeout(resolve, 3000)); // 3s Pause
                    rateLimitDetected = false;
                } else if (endTime - startTime < 800 && batchSize < 5) {
                    batchSize = Math.min(5, batchSize + 1);
                    console.log(`Batch completed quickly, increasing batch size to ${batchSize}`);
                }
                
                let batchUsers = [];
                let emptyPagesInBatch = 0;
                
                batchResults.forEach((result, index) => {
                    const users = result.users || result || [];
                    if (users.length === 0) {
                        emptyPagesInBatch++;
                    } else {
                        batchUsers.push(...users);
                    }
                });
                
                allUsers.push(...batchUsers);
                
                // Consecutive Empty Batch Logic
                if (batchUsers.length === 0) {
                    consecutiveEmptyBatches++;
                    console.log(`Empty batch ${currentBatch}, consecutive empty batches: ${consecutiveEmptyBatches}/${maxConsecutiveEmpty}`);
                } else {
                    consecutiveEmptyBatches = 0; // Reset counter wenn Daten gefunden
                }
                
                console.log(`Batch ${currentBatch} complete: ${batchUsers.length} users (total: ${allUsers.length})`);
                document.getElementById('totalStudents').textContent = `${allUsers.length}+ (loading...)`;
                
                currentBatch++;
                
                // Adaptive Pause - länger bei großen Datenmengen
                let pauseTime = 300; // Standard 300ms
                if (rateLimitDetected) pauseTime = 1000;
                if (allUsers.length > 20000) pauseTime = 500; // Langsamer bei vielen Usern
                if (allUsers.length > 40000) pauseTime = 800; // Noch langsamer
                
                await new Promise(resolve => setTimeout(resolve, pauseTime));
                
                // Progress update alle 50 Batches
                if (currentBatch % 50 === 0) {
                    console.log(`🔄 Progress check: ${allUsers.length} users loaded after ${currentBatch} batches`);
                }
            }
            
            console.log(`🎯 User loading complete: ${allUsers.length} users loaded (stopped after ${consecutiveEmptyBatches} consecutive empty batches)`);
            
            // Zusätzlicher Check: Versuche noch ein paar einzelne Pages um sicherzugehen
            if (allUsers.length < 50000 && consecutiveEmptyBatches >= maxConsecutiveEmpty) {
                console.log('🔍 Performing additional spot checks for missing data...');
                
                // Prüfe ein paar Pages weiter hinten
                const spotCheckPages = [currentBatch + 10, currentBatch + 50, currentBatch + 100];
                
                for (const page of spotCheckPages) {
                    try {
                        const spotCheckResult = await teachableAPI.getUsers(page);
                        const spotUsers = spotCheckResult.users || spotCheckResult || [];
                        
                        if (spotUsers.length > 0) {
                            console.log(`🔍 Found ${spotUsers.length} users on page ${page}! Continuing from there...`);
                            
                            // Setze neue Startposition und mache weiter
                            currentBatch = page;
                            consecutiveEmptyBatches = 0;
                            
                            // Lade weiter von dieser Position
                            while (consecutiveEmptyBatches < 3 && allUsers.length < 80000) {
                                try {
                                    const continueResult = await teachableAPI.getUsers(currentBatch);
                                    const continueUsers = continueResult.users || continueResult || [];
                                    
                                    if (continueUsers.length > 0) {
                                        allUsers.push(...continueUsers);
                                        consecutiveEmptyBatches = 0;
                                        console.log(`📈 Continued loading: page ${currentBatch}, ${continueUsers.length} users (total: ${allUsers.length})`);
                                    } else {
                                        consecutiveEmptyBatches++;
                                    }
                                    
                                    currentBatch++;
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    
                                } catch (error) {
                                    console.warn(`Spot check continuation failed on page ${currentBatch}:`, error);
                                    break;
                                }
                            }
                            
                            break; // Stoppe Spot Checks wenn wir erfolgreich waren
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (error) {
                        console.warn(`Spot check failed for page ${page}:`, error);
                    }
                }
            }
            
            console.log(`🏁 Final user count: ${allUsers.length} users`);
            document.getElementById('totalStudents').textContent = `${allUsers.length}`;
            
            // Log für Debugging
            if (allUsers.length < 40000) {
                console.warn(`⚠️  Only ${allUsers.length} users loaded - this might be incomplete for a 50k+ user base.`);
                console.log('Possible reasons:');
                console.log('- API pagination structure changed');
                console.log('- Rate limits are very strict');
                console.log('- Data is distributed non-consecutively');
                console.log('- API endpoint changed behavior');
            }
            
            // 3. Enrollments laden
            console.log('Loading enrollments...');
            let allEnrollments = [];
            let enrollmentBatch = 1;
            let enrollmentBatchSize = 3;
            
            while (enrollmentBatch <= 20) {
                const batchPromises = [];
                const startPage = (enrollmentBatch - 1) * enrollmentBatchSize + 1;
                const endPage = startPage + enrollmentBatchSize - 1;
                
                for (let page = startPage; page <= endPage; page++) {
                    batchPromises.push(
                        teachableAPI.getEnrollments(page).catch(error => {
                            console.warn(`Enrollment page ${page} failed:`, error);
                            return { enrollments: [] };
                        })
                    );
                }
                
                const batchResults = await Promise.all(batchPromises);
                let batchEnrollments = [];
                let emptyPages = 0;
                
                batchResults.forEach((result) => {
                    const enrollments = result.enrollments || result || [];
                    if (enrollments.length === 0) {
                        emptyPages++;
                    } else {
                        batchEnrollments.push(...enrollments);
                    }
                });
                
                allEnrollments.push(...batchEnrollments);
                
                if (emptyPages >= enrollmentBatchSize / 2) {
                    console.log('Stopping enrollment loading: too many empty pages');
                    break;
                }
                
                enrollmentBatch++;
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            // 4. Warte auf parallele Requests
            const [coursesResponse, freeA1UsersResponse] = await Promise.all([
                coursesPromise, 
                freeA1UsersPromise
            ]);
            
            const courses = coursesResponse.courses || coursesResponse || [];
            const freeA1Users = freeA1UsersResponse.users || freeA1UsersResponse || [];
            
            console.log(`Base data loaded: ${allUsers.length} users, ${allEnrollments.length} enrollments, ${courses.length} courses, ${freeA1Users.length} Free-A1 users`);
            
            // 5. ERWEITERTE ANALYTICS - Course Performance
            console.log('Analyzing course performance...');
            
            // Sample von Kursen für detaillierte Analyse (max 5 um Performance zu optimieren)
            const topCourses = courses.slice(0, 5);
            const courseAnalytics = [];
            
            for (const course of topCourses) {
                try {
                    console.log(`Analyzing course: ${course.name || course.id}`);
                    
                    const courseEnrollmentsResponse = await teachableAPI.getCourseEnrollments(course.id);
                    const courseEnrollments = courseEnrollmentsResponse.enrollments || courseEnrollmentsResponse || [];
                    
                    const courseProgress = await teachableAPI.getCourseProgress(course.id).catch(e => {
                        console.warn(`Course progress failed for ${course.id}:`, e);
                        return { progress: [] };
                    });
                    
                    // Course Analytics berechnen
                    const totalEnrollments = courseEnrollments.length;
                    const completedEnrollments = courseEnrollments.filter(e => 
                        e.percent_complete === 100 || e.status === 'completed'
                    ).length;
                    
                    const avgProgress = totalEnrollments > 0 ? 
                        Math.round(courseEnrollments.reduce((sum, e) => sum + (e.percent_complete || 0), 0) / totalEnrollments) : 0;
                    
                    const activeEnrollments = courseEnrollments.filter(e => 
                        (e.percent_complete || 0) > 1 && (e.percent_complete || 0) < 100
                    ).length;
                    
                    courseAnalytics.push({
                        course: course,
                        totalEnrollments: totalEnrollments,
                        completedEnrollments: completedEnrollments,
                        completionRate: totalEnrollments > 0 ? Math.round((completedEnrollments / totalEnrollments) * 100) : 0,
                        avgProgress: avgProgress,
                        activeEnrollments: activeEnrollments,
                        dropoutRate: totalEnrollments > 0 ? Math.round(((totalEnrollments - activeEnrollments - completedEnrollments) / totalEnrollments) * 100) : 0
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 500)); // Rate limiting
                    
                } catch (error) {
                    console.error(`Error analyzing course ${course.id}:`, error);
                }
            }
            
            console.log('Course analytics complete:', courseAnalytics);
            
            // 6. User Segmentation
            console.log('Performing user segmentation...');
            
            // Erstelle User-Enrollment Map
            const userEnrollmentMap = new Map();
            allEnrollments.forEach(enrollment => {
                const userId = enrollment.user_id || enrollment.user?.id;
                if (userId) {
                    if (!userEnrollmentMap.has(userId)) {
                        userEnrollmentMap.set(userId, []);
                    }
                    userEnrollmentMap.get(userId).push(enrollment);
                }
            });
            
            // User Segmentierung
            const powerUsers = []; // 3+ Kurse
            const atRiskUsers = []; // Gestoppter Progress
            const recentUsers = []; // Anmeldung in letzten 30 Tagen
            const activeUsers = [];
            
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            allUsers.forEach(user => {
                const userEnrollments = userEnrollmentMap.get(user.id) || [];
                const enrollmentCount = userEnrollments.length;
                
                // Power Users (3+ Kurse)
                if (enrollmentCount >= 3) {
                    powerUsers.push(user);
                }
                
                // Recent Users
                if (user.created_at && new Date(user.created_at) > thirtyDaysAgo) {
                    recentUsers.push(user);
                }
                
                // At-Risk Users (haben Kurse, aber kein Progress in letzter Zeit)
                const hasStagnantProgress = userEnrollments.some(e => 
                    (e.percent_complete || 0) > 1 && 
                    (e.percent_complete || 0) < 90 &&
                    e.updated_at && 
                    new Date(e.updated_at) < thirtyDaysAgo
                );
                
                if (hasStagnantProgress) {
                    atRiskUsers.push(user);
                }
                
                // Active Users
                const hasRecentActivity = userEnrollments.some(e => 
                    e.updated_at && new Date(e.updated_at) > thirtyDaysAgo
                );
                
                if (hasRecentActivity) {
                    activeUsers.push(user);
                }
            });
            
            // 7. Grundlegende Metriken berechnen
            const totalStudents = allUsers.length;
            const totalEnrollments = allEnrollments.length;
            const freeA1Count = freeA1Users.length;
            
            let avgProgress = 0;
            let completedCount = 0;
            let activeStudents = 0;
            
            console.log('Sample user object:', allUsers[0]);
            console.
```